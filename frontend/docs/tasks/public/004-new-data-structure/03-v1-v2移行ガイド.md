# BOM v1 → v2 ダミーデータ移行ガイド

このドキュメントは、v1ダミーデータからv2ダミーデータへの移行における注意点とパターンをまとめたものです。
`home` → `home-v2` の実装経験を基に、他ページへの適用指針を提供します。

---

## 1. データ構造の根本的な違い

### v1: ネスト型ツリー構造

v1では、データはネストされたツリー構造として格納されています。

```typescript
// v1の型定義 (shared/dummy-data/bom/products.ts)
interface BomNode {
  id: string;
  name: string;
  nodeType: NodeType;        // '製品' | 'Assy' | 'Part' 等
  quantity: number;
  children?: BomNode[];      // 子ノードを直接含む
}

interface BomNodeDetail {
  id: string;
  name: string;
  nodeType: NodeType;
  quantity: number;
  customItems: Record<string, string | number | boolean>;  // メタデータを直接埋め込み
  documents: { id: string; typeName: string; name: string }[];
  drawings: { id: string; name: string; previewImageUrl: string }[];
  createdAt: string;
  updatedAt: string;
}
```

**特徴:**
- ツリー構造が事前に構築されている（`children`で直接参照）
- メタデータは`customItems`として`Record<string, unknown>`形式で埋め込み
- 型安全性が低い（スキーマ定義なし）
- 製品→BomNode→BomNodeDetailという単純な参照

### v2: リレーショナル＋Facet構造

v2では、正規化されたリレーショナル構造とFacetシステムを採用しています。

```typescript
// v2の型定義 (shared/dummy-data/bom-v2/types.ts)

// Core層
interface Item {
  id: string;
  partNumber: string;        // 品番（P/N）
  name: string;
  itemType: ItemType;        // 'Product' | 'Assembly' | 'Part' 等
  lifecycleState: LifecycleState;
}

interface ItemRev {
  id: string;
  itemId: string;            // Item参照
  revision: string;          // "A", "B", "C"...
  status: RevisionStatus;    // 'Draft' | 'Released' 等
  facetInstanceIds: string[]; // Facetへの参照
}

// BOM構造層（単層、再帰解決）
interface BOMHeader {
  id: string;
  parentItemRevId: string;   // 親ItemRev参照
  bomType: BomType;          // 'EBOM' | 'MBOM'
}

interface BOMLine {
  id: string;
  bomHeaderId: string;       // BOMHeader参照
  childItemRevId: string;    // 子ItemRev参照
  quantity: number;
}

// Facet層（スキーマベース属性）
interface FacetType {
  id: string;
  code: string;
  schema: FacetSchema;       // JSONスキーマ定義
  applicableItemTypes: ItemType[];
}

interface FacetInstance {
  id: string;
  facetTypeId: string;       // スキーマへの参照
  values: Record<string, unknown>; // 実際の値
}
```

**特徴:**
- 正規化されたリレーショナル構造
- ツリーは実行時に`explodeBom()`で構築
- メタデータはFacetシステムでスキーマ駆動
- Item/ItemRev分離でリビジョン管理が可能

---

## 2. データ取得パターンの変更

### 製品リストの取得

```typescript
// v1
import { dummyProducts } from '@/shared/dummy-data/bom/products';
const products = dummyProducts; // Product[]

// v2
import { getItemsByType } from '@/shared/dummy-data/bom-v2';
const products = getItemsByType('Product'); // Item[]
```

**注意点:**
- v1の`Product.productName` → v2では`Item.name`
- v1の`Product.productNumber` → v2では`Item.partNumber`

### BOMツリーの構築

```typescript
// v1: 事前構築済みツリーをそのまま使用
import { getBomByProductId, bomNodesToTreeNodes } from '@/shared/dummy-data/bom/products';
const bomTree = getBomByProductId(productId); // BomNode[]（ネスト済み）
const treeNodes = bomNodesToTreeNodes(bomTree);

// v2: フラットな展開結果からツリーを構築
import { explodeBom, getItemById, getLatestReleasedRev } from '@/shared/dummy-data/bom-v2';

const productRev = getLatestReleasedRev(productId); // 最新リリース版を取得
const explosion = explodeBom(productRev.id);        // フラット配列として展開

// フラット→ツリー変換が必要
const nodeMap = new Map<string, BomTreeNode>();
const root: BomTreeNode = { itemRev: productRev, item: productItem, children: [] };
nodeMap.set(productRev.id, root);

for (const row of explosion.sort((a, b) => a.level - b.level)) {
  const node = { itemRev: row.childItemRev, item: row.childItem, children: [] };
  nodeMap.set(row.childItemRevId, node);
  nodeMap.get(row.parentItemRevId)?.children.push(node);
}
```

**重要な違い:**
1. v2ではItemRev経由でアクセス（`getLatestReleasedRev`で最新版を取得）
2. `explodeBom`はフラット配列を返すので、ツリー構造への変換が必要
3. 親子関係は`parentItemRevId`で辿る

### ノード詳細の取得

```typescript
// v1
import { getNodeDetailById } from '@/shared/dummy-data/bom/products';
const detail = getNodeDetailById(nodeId); // BomNodeDetail | undefined

// v2: 複数のクエリを組み合わせる
import {
  getItemRevById,
  getItemById,
  getFacetInstancesByItemRev,
  getDrawingsByItemRev,
  getDocumentsByItemRev,
} from '@/shared/dummy-data/bom-v2';

const itemRev = getItemRevById(itemRevId);
const item = getItemById(itemRev.itemId);
const facetInstances = getFacetInstancesByItemRev(itemRevId);
const drawings = getDrawingsByItemRev(itemRevId);
const documents = getDocumentsByItemRev(itemRevId);
```

**重要な違い:**
- v1: 1つのAPI呼び出しで全情報取得
- v2: 正規化されているため複数クエリを組み合わせ
- v2では`useMemo`でまとめて取得するのが効率的

---

## 3. メタデータ表示の違い（最重要）

### v1: 固定フィールド + customItems

v1では、基本フィールドは固定で、追加属性は`customItems`として動的レンダリングしていました。

```typescript
// v1の MetadataFields コンポーネント
interface MetadataFormData {
  id: string;
  name: string;
  nodeType: string;
  quantity: number | '';
  createdAt: string;
  updatedAt: string;
  customItems: Record<string, string | number | '' | boolean>;  // スキーマなし
}

// レンダリング
<TextField label="名前" value={formData.name} />
<TextField label="ノードタイプ" value={formData.nodeType} />
<NumberField label="数量" value={formData.quantity} />
{renderDynamicFields(formData.customItems, onCustomItemChange)} // スキーマなしで推測
```

**問題点:**
- `customItems`の型がわからない（stringかnumberかbooleanか推測）
- UIコンポーネントの選択が困難
- バリデーションルールなし

### v2: Facetシステムによるスキーマ駆動

v2では、FacetTypeがスキーマを定義し、FacetInstanceが値を保持します。

```typescript
// FacetType の例（スキーマ定義）
{
  id: "ft_001",
  code: "DESIGN_SPEC",
  name: "設計仕様",
  schema: {
    type: "object",
    properties: {
      material: {
        type: "string",
        title: "材質",
        enum: ["アルミニウム", "ステンレス", "鉄"]  // 選択肢
      },
      weight: {
        type: "number",
        title: "重量",
        unit: "kg",
        minimum: 0
      }
    }
  }
}

// FacetInstance の例（実際の値）
{
  id: "fi_001",
  facetTypeId: "ft_001",
  values: {
    material: "アルミニウム",
    weight: 2.5
  }
}
```

```typescript
// v2の MetadataFields コンポーネント
interface MetadataFieldsProps {
  item: Item;
  itemRev: ItemRev;
  facetInstances: FacetInstance[];
  formData: Record<string, unknown>;
  onFieldChange: (key: string, value: unknown) => void;
}

export function MetadataFields({ item, itemRev, facetInstances, formData, onFieldChange }) {
  return (
    <div className="space-y-6">
      {/* 基本情報（固定フィールド） */}
      <div>
        <h4>基本情報</h4>
        <TextField label="品番" value={item.partNumber} disabled />
        <TextField label="品名" value={item.name} disabled />
        <TextField label="リビジョン" value={itemRev.revision} disabled />
      </div>

      {/* Facet属性（スキーマ駆動） */}
      {facetInstances.map((instance) => {
        const facetType = getFacetTypeById(instance.facetTypeId);
        return (
          <div key={instance.id}>
            <h4>{facetType.name}</h4>
            {Object.entries(facetType.schema.properties).map(([key, prop]) => (
              <FacetPropertyField
                key={key}
                propertyKey={key}
                property={prop}        // スキーマから型情報を取得
                value={formData[key]}
                onChange={(value) => onFieldChange(key, value)}
              />
            ))}
          </div>
        );
      })}
    </div>
  );
}

// スキーマに基づいてUIを決定
function FacetPropertyField({ propertyKey, property, value, onChange }) {
  const label = property.title + (property.unit ? ` (${property.unit})` : '');

  // enumがある場合 → SelectField
  if (property.enum && property.enum.length > 0) {
    return <SelectField label={label} options={...} value={value} onChange={onChange} />;
  }

  // 数値型 → NumberField
  if (property.type === 'number') {
    return <NumberField label={label} value={value} onChange={onChange} />;
  }

  // 文字列型 → TextField
  return <TextField label={label} value={value} onChange={onChange} />;
}
```

**メリット:**
- スキーマから適切なUIコンポーネントを自動選択
- `enum`があればSelectField、`number`ならNumberField
- `unit`があればラベルに単位を表示
- `minimum`/`maximum`でバリデーション可能

---

## 4. Drawing/Document の取得パターン

### v1: 詳細に埋め込み

```typescript
// v1
const detail = getNodeDetailById(nodeId);
const documents = detail.documents; // { id, typeName, name }[]
const drawings = detail.drawings;   // { id, name, previewImageUrl }[]
```

### v2: ItemRev経由で関連取得

```typescript
// v2
import { getDrawingsByItemRev, getDocumentsByItemRev } from '@/shared/dummy-data/bom-v2';

const drawings = getDrawingsByItemRev(itemRevId); // Drawing[]
const documents = getDocumentsByItemRev(itemRevId); // Document[]

// Drawing型はより詳細
interface Drawing {
  drawingNumber: string;
  title: string;
  drawingType: string;   // "組立図", "部品図" 等
  sheetSize: string;     // "A1", "A2" 等
  filePath?: string;
}

// Document型もDocumentTypeを参照
interface Document {
  documentNumber: string;
  title: string;
  documentTypeId: string;  // DocumentType参照
  filePath?: string;
}

// DocumentTypeの名前を取得
const docType = getDocumentTypeById(doc.documentTypeId);
console.log(docType.name); // "見積書", "発注書" 等
```

---

## 5. 選択状態の管理

### v1: nodeIdで管理

```typescript
// v1
const [selectedNodeId, setSelectedNodeId] = useState<string | null>(null);
const selectedNodeDetail = selectedNodeId ? getNodeDetailById(selectedNodeId) : undefined;
```

### v2: itemRevIdで管理

```typescript
// v2
const [selectedItemRevId, setSelectedItemRevId] = useState<string | null>(null);

// ItemRevIdからItem情報も取得可能
const itemRev = selectedItemRevId ? getItemRevById(selectedItemRevId) : null;
const item = itemRev ? getItemById(itemRev.itemId) : null;
```

**重要:**
- v2ではItemRevが参照の基本単位
- ItemRevからItem（品番情報）を取得する追加ステップが必要
- 詳細ページへのリンクは`item.id`を使う

---

## 6. 型の変換・マッピング

### NodeType → ItemType

| v1 (NodeType) | v2 (ItemType) |
|---------------|---------------|
| '製品' | 'Product' |
| 'Assy' | 'Assembly' |
| 'SubAssy' | 'Assembly' |
| 'Module' | 'Assembly' |
| 'Part' | 'Part' / 'Purchased' |

### 主要フィールドの対応

| v1 | v2 |
|----|-----|
| `BomNode.id` | `ItemRev.id` |
| `BomNode.name` | `Item.name` |
| `BomNode.nodeType` | `Item.itemType` |
| `BomNode.quantity` | `BOMLine.quantity` |
| `BomNodeDetail.customItems` | `FacetInstance.values` |
| `Product.productNumber` | `Item.partNumber` |
| `Product.productName` | `Item.name` |

---

## 7. 移行チェックリスト

他ページをv2に移行する際は、以下を確認してください：

### データ取得
- [ ] `dummyProducts` → `getItemsByType('Product')` に変更
- [ ] `getBomByProductId` → `getLatestReleasedRev` + `explodeBom` に変更
- [ ] `getNodeDetailById` → `getItemRevById` + 関連クエリに変更
- [ ] 必要に応じて`useMemo`でデータ取得をまとめる

### ツリー構築
- [ ] ネスト済みデータ → フラット展開からのツリー構築に変更
- [ ] `children`プロパティ → `parentItemRevId`での親子関連付けに変更
- [ ] `nodeId` → `itemRevId`への選択状態変更

### メタデータ表示
- [ ] 固定フィールドのマッピング（name, partNumber等）
- [ ] `customItems` → FacetInstance経由の動的レンダリングに変更
- [ ] FacetType.schemaを参照してUIコンポーネントを選択

### Drawing/Document
- [ ] 詳細埋め込み → `getDrawingsByItemRev`, `getDocumentsByItemRev`に変更
- [ ] DocumentTypeの名前取得には`getDocumentTypeById`を使用

### 型定義
- [ ] Propsの型を`BomNode` → `ItemRev` + `Item`に変更
- [ ] コールバックの引数型を更新

---

## 8. よくあるエラーと対処法

### 1. `undefined`の扱い

```typescript
// NG: getLatestReleasedRevはundefinedを返す可能性がある
const selectedProductRev = getLatestReleasedRev(selectedProductId);

// OK: null合体演算子で明示的にnullに変換
const selectedProductRev = selectedProductId
  ? getLatestReleasedRev(selectedProductId) ?? null
  : null;
```

### 2. インポートパスの違い

```typescript
// v1
import { ... } from '@/shared/dummy-data/bom/products';

// v2
import { ... } from '@/shared/dummy-data/bom-v2';
```

### 3. 詳細ページへのリンク

```typescript
// v1: nodeIdをそのまま使用
router.push(`/bom/${detail.id}/basic-information`);

// v2: ItemのIDを使用（ItemRevのIDではない）
router.push(`/bom/${item.id}/basic-information`);
```

---

## 9. 設計思想のまとめ

| 観点 | v1 | v2 |
|------|-----|-----|
| データモデル | ドキュメント型（ネスト） | リレーショナル（正規化） |
| ツリー構造 | 事前構築済み | 実行時構築 |
| 属性管理 | 自由形式（customItems） | スキーマ駆動（Facet） |
| バージョン管理 | なし | ItemRev分離 |
| 拡張性 | 低（固定構造） | 高（Facet追加可能） |
| 型安全性 | 低 | 高（スキーマ定義） |

v2への移行は単なるデータソース変更ではなく、**設計パラダイムの変更**です。
UI/レイアウトは維持しつつ、データアクセス層を再設計する意識で取り組んでください。
