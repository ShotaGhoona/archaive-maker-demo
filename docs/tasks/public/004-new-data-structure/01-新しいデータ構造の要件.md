### BOMアーキテクチャ完全理解講座（全7章）

### **第1章：すべての基本、「モノ」と「版」の分離**

**～ItemとItemRev～**
なぜ「品番（P/N）」と「リビジョン（Rev）」を別のテーブルに分ける必要があるのか？BOMの最小単位である「Core」の考え方と、なぜここに余計な属性を持たせてはいけないのかを理解します。

- 詳細
    
    ## 第1章：すべての基本、「モノ」と「版」の分離
    
    **～ItemとItemRev～**
    
    BOM（部品表）システムを作る際、初心者が最初にやってしまう最大の失敗は、**「部品（Item）テーブルにすべての情報を詰め込むこと」**です。
    
    今回のBizPMの設計では、それを避けるために**「Item（モノ）」**と**「ItemRev（版）」**という2つのテーブルにはっきりと分けています。まずはこの2つの役割の違いを、直感的に理解しましょう。
    
    ### 1. 「フォルダ」と「書類」で考える
    
    この2つの関係は、オフィスの**「フォルダ」**と、その中に入っている**「書類」**の関係に似ています。
    
    - **Item（フォルダ）**
        - **役割：** 「これは『モーターA』である」という**アイデンティティ（名札）**を管理する器。
        - **特徴：** 中身が改良されても、この「器」自体は変わりません。
        - **BizPMの設計：** `pn`（品番）や `name`（名称）はここにあります。
    - **ItemRev（書類）**
        - **役割：** 「モーターAの**第1版（Rev A）の具体的な仕様」というスナップショット（実体）**。
        - **特徴：** 設計変更（寸法変更など）が起きると、新しい書類（Rev B）が追加されます。過去のRev Aも履歴として残ります。
        - **BizPMの設計：** `status`（承認済みかどうか）や `change_order_id`（変更理由）はここにあります。
    
    ### 2. なぜ分ける必要があるのか？
    
    「テーブルを1つにして、今のバージョンだけ保存すれば簡単じゃないか？」と思うかもしれません。しかし、製造業では**「過去の正しさ」**と**「現在の正しさ」**の両方が必要になるため、分けることが必須になります。
    
    ### 理由①：BOMの「再現性」を守るため
    
    例えば、製品X（Rev A）を作っていたときに使っていた部品Yは「Rev A」だったとします。
    もし部品Yが改良されて「Rev B」になったとき、テーブルを上書きしてしまうと、「昔作った製品X（Rev A）はどんな構成だったか？」が分からなくなります（監査で詰められます）。
    **「ItemRev」として履歴を残すことで、過去の構成を完全に再現できます。**
    
    ### 理由②：BOMのつながり（参照先）を明確にするため
    
    今回のER図をよく見ると、`BOMLine`（構成情報の行）は、`Item`ではなく**`ItemRev`（child_item_rev_id）**を参照しています。
    
    - **× ダメな指定：** 「モーターAを使ってくれ」（Itemを指定）
        - 現場：「どのバージョンのモーターA？最新でいいの？在庫の古いやつ？」と混乱します。
    - **○ 正しい指定：** 「モーターAの **Rev B** を使ってくれ」（ItemRevを指定）
        - 現場：「了解、Rev Bですね」と一意に決まります。
    
    ### 3. 仕様書（BizPMファイル）との答え合わせ
    
    ここで、最初に共有いただいたBizPMの定義を見てみましょう。非常に理にかなった設計になっています。
    
    > Core | Item
    > 
    > - **P/N（品番）の器：** 全BOMの共通参照点
    > - `pn`: 文字列で自由（企業差が大きいので）
    > - `lifecycle_state`: Itemとしての状態（廃番など）
    
    > Core | ItemRev
    > 
    > - **品番の版：** BOMが参照する最小単位
    > - `rev`: リビジョン（A, B, 1, 2...）
    > - `status`: Released（承認済）などの版ごとの状態
    
    ### 💡 ここでの重要な「制約」
    
    BizPMの設計メモに**「Coreは“少なすぎる”くらいに固定し、企業差はFacetへ逃がす」**とあります。
    
    - Itemテーブルに「価格」を持たせてはいけません。（価格は時期や購入先で変わるから）
    - ItemRevテーブルに「RoHS対応状況」を持たせてはいけません。（後から測定し直すかもしれないから）
    
    **ItemとItemRevは、あくまで「BOMの骨格（IDと履歴）」を作るためだけに存在する**、というのがこの第1章の結論です。
    
    ---
    
    ### 第1章のまとめ
    
    1. **Item**は「変わらない名札（器）」、**ItemRev**は「特定の時点の仕様（中身）」である。
    2. BOMは、曖昧さをなくすために**ItemRev**同士をつなぐ（これを「Fixed Rev」方式と呼びます）。
    3. ここには「属性（色、重さ、価格）」はまだ入れない。これらは後で出てくるFacetの仕事。

### **第2章：BOMの背骨を作る「構造」**

**～BOMHeaderとBOMLine～**
親子関係をどう表現するか。単純なツリー構造から一歩進んで、「この構成はいつから有効か？」を管理するための基礎を作ります。ここではまだ「属性（ファセット）」は登場しません。

- 詳細
    
    ## 第2章：BOMの背骨を作る「構造」
    
    **～BOMHeaderとBOMLine～**
    
    BOM（部品表）とは、突き詰めると**「親が子を、いくつ、どのように使うか」**という情報の集まりです。
    BizPMの設計では、この関係を `BOMHeader` と `BOMLine` という2つのオブジェクトで表現しています。
    
    ### 1. 「料理のレシピ」でイメージする
    
    BOMの構造は、料理のレシピに例えると非常に分かりやすくなります。
    
    - **ItemRev（第1章で作ったもの）：**
        - スーパーで売っている「食材」そのものです。（例：卵、牛乳、小麦粉）
        - これ単体では、「何個使うか」の情報は持っていません。
    - **BOMLine（今回作るもの）：**
        - レシピの**「1行」**です。（例：卵を **2個**、牛乳を **200ml**）
        - ここで初めて「数量（Qty）」や「順序」という意味が生まれます。
    
    ### 2. 登場人物：HeaderとLineの関係
    
    なぜ単純に「親Item」と「子Item」を直接つながないのでしょうか？
    間に **`BOMHeader`** というクッションを挟むのが、このアーキテクチャの肝です。
    
    ### 構造図のイメージ
    
    コード スニペット
    
    `ItemRev (親：完成車 Rev A)
       │
       └── BOMHeader (「設計BOM」という表紙)
             │
             ├── BOMLine 1 ──> ItemRev (子：エンジン Rev C)  Qty: 1
             │
             ├── BOMLine 2 ──> ItemRev (子：タイヤ Rev B)    Qty: 4
             │
             └── BOMLine 3 ──> ItemRev (子：ハンドル Rev A)  Qty: 1`
    
    それぞれの役割をBizPMの仕様書に基づいて解説します。
    
    ### ① BOMHeader（表紙）
    
    - **役割：** 「これは何のBOMか？」を定義するヘッダー情報。
    - **なぜ必要か？**
        - 同じ「完成車 Rev A」でも、**「設計用の構成」**と**「製造用の構成」**は違うかもしれません。
        - `parent_item_rev_id`（親）に対して、複数の `BOMHeader`（bom_type=EBOM, bom_type=MBOM）をぶら下げることで、**用途ごとの構成図**を管理できます。
    - **BizPM設計のポイント：**
        - `bom_id` を主キーとして持っています。これにより、「バージョン管理されたBOMの塊」として扱えます。
    
    ### ② BOMLine（行）
    
    - **役割：** 具体的に「どの子部品」を「いくつ」使うかという指示書。
    - **BizPM設計のポイント：**
        - `child_item_rev_id`：必ず**「ItemRev（特定の版）」**を指します。「Item（どの版でもいい）」を指すことは（基本的には）ありません。これにより「いつ作っても同じものができる」ことを保証します。
        - `find_number`：行番号（10, 20, 30...）。CAD上のバルーン番号などと合わせるために重要です。
        - `qty`：数量。
    
    ### 3. 「属性」はどこに持つべきか？
    
    ここで初心者が陥りやすい罠があります。
    **「ボルトの締め付けトルク（Torque）」という情報は、どこに保存すべきでしょうか？**
    
    - **選択肢A：** ボルトの `ItemRev` に書く？
        - **× 間違い。** ボルト自体はただの金属部品です。場所によって強く締めたり、弱く締めたりします。ボルトそのものの属性ではありません。
    - **選択肢B：** `BOMLine` に書く？
        - **◎ 正解。** 「この親部品を作るために、このボルトを使うとき」の属性だからです。
    
    BizPMの設計では、`BOMLine` には `line_type` や `notes` などの最低限の固定列しか用意されていません。
    もし「トルク値」や「接着剤の塗布量」といった特殊な属性が必要な場合は、ここでも **Facet（ファセット）** が登場します（詳しくは次章）。
    `BOMLine` 自体も、Facetを取り付けるための「フック（ひっかけ場所）」としての役割を果たします。
    
    ### 4. 単階層と多階層
    
    データベースに保存されるのは、あくまで**「親→子」の1階層（Single Level）**だけです。
    
    - 車 → エンジン
    - エンジン → ピストン
    
    システムがBOMを表示するときは、この1階層のつながりをバケツリレーのように辿っていき、自動的に**多階層（Multi Level）のツリー**として画面に描画します。
    これにより、何万点という部品からなる製品でも、データ構造をシンプルに保つことができます。
    
    ---
    
    ### 第2章のまとめ
    
    1. **BOMHeader** は、親ItemRevに対する「構成表の表紙」である（設計用、製造用などを区別する）。
    2. **BOMLine** は、レシピの1行であり、「子ItemRev」と「数量」を結びつける。
    3. 「構成としての属性（トルクや位置など）」は、部品そのものではなく、この **Line（関係性）** に持たせることになる。
    
    ここまでで、部品と部品をつなぐ「骨格」ができあがりました。
    しかし、これだけではただのリストです。実業務では「調達リードタイム」や「RoHS判定」など、部門ごとに大量の管理項目が必要です。
    

### **第3章：この設計の核心、「Facet（ファセット）」**

**～属性爆発（スーパーテーブル問題）の解決～**
本設計の最大の目玉です。「設計部門」と「購買部門」で見たい項目が違う問題をどう解決するか？
「FacetType（型）」と「FacetInstance（実体・JSON）」というオブジェクトを使い、システムを改修せずに管理項目を増やす仕組みを学びます。

- 詳細
    
    ## 第3章：この設計の核心、「Facet（ファセット）」
    
    **～属性爆発（スーパーテーブル問題）の解決～**
    
    第1章と第2章で、BOMの「骨格（Item/ItemRev/BOM）」は完成しました。
    しかし、現場の業務はこれだけでは回りません。「価格は？」「材質は？」「RoHS指令は？」「梱包サイズは？」……といった、膨大な**「属性（メタデータ）」**が必要になります。
    
    これを解決するための仕組みが **Facet（ファセット）** です。
    
    ### 1. 従来の「悪夢」：スーパーテーブル問題
    
    伝統的なシステムでは、新しい管理項目が増えるたびに、エンジニアがデータベースの `Item` テーブルにカラム（列）を追加していました。
    
    - **設計部：** 「重量（Weight）カラムを追加して！」
    - **購買部：** 「仕入先コード（SupplierCode）カラムを追加して！」
    - **品証部：** 「RoHS判定（RoHS_Status）カラムを追加して！」
    
    これを繰り返すと、**数百～数千カラムある巨大なテーブル**ができあがります。しかも、ある部品には「重量」が入っているが「RoHS」は空っぽ（NULL）……という、穴だらけの非効率なテーブルになります。これを**「スーパーテーブル問題」**と呼びます。
    
    ### 2. 解決策：スマホとアプリの関係で考える
    
    BizPM氏の設計は、この問題を**「スマホ（Core）」**と**「アプリ（Facet）」**の関係に置き換えて解決しました。
    
    - **Item（Core） = スマートフォン本体**
        - 全員が持っている共通の基盤。
        - OSや電話番号（ID）など、最低限の機能しかない。
    - **Facet = アプリ**
        - *「購買アプリ」**をインストールすると、価格やLTが見られるようになる。
        - *「規制アプリ」**をインストールすると、RoHSやREACHが見られるようになる。
        - 必要ない部品には、インストールしなければいい（データ容量を食わない）。
    
    つまり、**「1つの巨大なItemテーブル」を作るのではなく、「小さな属性の塊（Facet）」をItemにくっつける**、という発想です。
    
    ### 3. 実装の仕組み：TypeとInstance
    
    この仕組みを実現するために、BizPM氏は以下の2つのテーブルを用意しています。ここが技術的な肝です。
    
    ### ① FacetType（ファセットの「型」）
    
    - **役割：** 「こういう属性セットを定義します」という**設計図**。
    - **中身：** 具体的なデータではなく、**JSON Schema**（データの枠組み）を持ちます。
    - **例：** `REG_ChemicalCompliance`（化学物質管理用ファセット）
        - 「`rohs_status` という項目が必要で、値は `OK/NG` のどちらかだよ」と定義する。
    
    ### ② FacetInstance（ファセットの「実体」）
    
    - **役割：** 実際に部品に貼り付けられた**付箋紙**。
    - **中身：** 具体的な値（**values_json**）を持ちます。
    - **例：** 「モーターA（Rev 1）」に貼り付けられた化学物質管理ファセット
        - 値：`{ "rohs_status": "OK", "checked_at": "2025-01-01" }`
    
    ### 4. この設計の凄さ
    
    BizPM氏の仕様書にある「パターンC：ハイブリッド」の採用により、以下のメリットが生まれます。
    
    1. **開発がいらない（NoCode化）：**
        - 「明日から新規格の管理が必要になった」と言われても、エンジニアがDBのカラムを追加する必要はありません。ユーザー権限で `FacetType` を作れば、即座に入力が開始できます。
    2. **部門間の干渉を防ぐ：**
        - 購買部のファセットをいじっても、設計部のファセットには何の影響もありません。権限管理も「ファセット単位」で行えます（設計者は購買ファセットを見せない、など）。
    3. **Coreを汚さない：**
        - Itemテーブルは常にクリーンな状態（IDと名前だけ）に保たれるため、システムの寿命が延びます。
    
    ### 5. 実際のデータイメージ
    
    頭の中で、テーブル結合をイメージしてみてください。
    
    **[Item Table]**
    | Item ID | Name |
    | :--- | :--- |
    | **I-001** | モーターA |
    
    **[FacetInstance Table]** (I-001に紐づいているもの)
    | Instance ID | Target | Facet Type | Values (JSON) |
    | :--- | :--- | :--- | :--- |
    | FI-101 | **I-001** | **購買情報** | `{ "price": 100, "supplier": "S-99" }` |
    | FI-102 | **I-001** | **品質情報** | `{ "rohs": "OK" }` |
    
    このように、I-001に対して複数のレコードがぶら下がる形になります（これを縦持ち、EAVパターンと呼びます）。
    
    ---
    
    ### 第3章のまとめ
    
    1. すべての属性をItemテーブルに入れるのはやめる（スーパーテーブル問題の回避）。
    2. 属性は**Facet（ファセット）**として切り出し、必要な部品にだけ貼り付ける。
    3. **FacetType**でデータの型（スキーマ）を定義し、**FacetInstance**のJSONカラムに実際の値を保存する。
    
    これで、「骨格（Core）」に「肉（Facet）」がつきました。単体の部品としてはこれで完成です。
    

### **第4章：多次元BOMへの拡張**

**～Context（視点）とEffectivity（有効性）～**
「設計BOM（EBOM）」と「製造BOM（MBOM）」を別々のテーブルにするのではなく、同じ箱の中で「Context」を使って切り替える手法について。さらに、日付やシリアル番号で構成を切り替える「Effectivity」の仕組みを解説します。

- 詳細
    
    ## 第4章：多次元BOMへの拡張
    
    **～Context（視点）とEffectivity（有効性）～**
    
    第3章までは、「1つのBOMツリー」に対して、色々な属性（付箋）を貼る話でした。
    しかし現実の製造業では、**「設計部門と製造部門で、そもそもツリーの形が違う」**という厄介な問題が発生します。
    
    これを解決するのが **Context（コンテキスト）** と **Effectivity（エフェクティビティ）** です。
    
    ### 1. Context： 「メガネ」を掛け替える
    
    BizPM氏の設計には `context_id` という項目が登場します。これは**「どの視点（メガネ）でBOMを見るか」**を指定するスイッチです。
    
    ### 問題：EBOMとMBOMの乖離
    
    - **設計(EBOM)：** 「この製品は機能的に3つのモジュールでできています」
    - **製造(MBOM)：** 「いやいや、工場ではラインの都合上、その3つをバラして別の順序で組み立てるよ。あと、設計図にはない『接着剤』や『梱包材』もBOMに入れてくれないと困る」
    
    従来は、これに対応するために「Itemをコピーして別のItem番号を振る」などの無理をしていました。
    
    ### 解決策：Contextで切り替える
    
    この設計では、1つの `ItemRev`（親）の下に、複数の `BOMHeader` をぶら下げることができます。
    
    - **ItemRev (製品X)**
        - **BOMHeader 1 (Context: 設計)**
            - 子：モジュールA, B, C
        - **BOMHeader 2 (Context: 京都工場・製造)**
            - 子：パーツa1, a2, b1, 接着剤, 梱包箱
    
    ユーザーがシステムにログインする際、「私は**設計者**です」と言えばBOMHeader 1が、「私は**京都工場の製造担当**です」と言えばBOMHeader 2が表示されます。
    モノ（ItemRev）は同じなのに、Contextによって**「見える構成」**がガラリと変わるのです。
    
    ### 2. Effectivity： 「時間」と「条件」の魔法
    
    次に `effectivity_id` です。これはBOMの有効期限や条件を制御します。
    
    ### 問題：いつ切り替わるのか？
    
    「来月の1日から、部品Aを部品Bに切り替えたい」という変更（ECO）があった場合、どう管理するか。
    
    ### 解決策：日付、シリアル、号機管理
    
    BizPM氏の設計では、`Effectivity` オブジェクトを独立させています。
    
    - **Date Effectivity（日付）：**
        - 「2025/04/01 ～ 2029/12/31 まで有効」
    - **Serial Effectivity（シリアル）：**
        - 「製造番号 #1000 ～ #1999 まで有効」
        - （自動車や航空機など、個体管理が厳しい業界で必須）
    - **Unit Effectivity / Config（仕様）：**
        - 「仕向け地＝北米」かつ「グレード＝High」の場合のみ有効
    
    これを `BOMLine` に紐付けることで、システムは以下の問い合わせに答えられるようになります。
    
    > 「2025年5月に製造する、北米向けのシリアル#1500の製品のBOMを出して」
    > 
    
    システムは、ContextとEffectivityのフィルタを通して、その瞬間の正しいBOM構成（部品リスト）を1つに定めて出力します（これを「BOMの展開（Explosion）」と呼びます）。
    
    ### 3. Facetとの組み合わせ（最強の柔軟性）
    
    ここで第3章の知識と組み合わせます。
    
    - **Context** は、「日本工場」と「アメリカ工場」で**調達先**を変えるときにも使えます。
        - Item自体は世界共通。
        - しかし `SourcingPolicy`（調達方針）は、Context（工場）ごとに別々のレコードを持つ。
        - 結果：「日本工場Context」で見ると仕入先はA社、「アメリカ工場Context」で見ると仕入先はB社に見える。
    
    ### 第4章のまとめ
    
    1. **Context** は「場所や用途の視点」。設計(E)と製造(M)の違いや、工場ごとの違いを吸収する。
    2. **Effectivity** は「時間や条件の範囲」。いつからいつまで、どのシリアル番号にその部品を使うかを定義する。
    3. これらを使うことで、**「たった一つの製品ID（ItemRev）」から、あらゆる状況に応じた正解のBOMを引き出す**ことができる（One Source, Multi View）。
    
    これで、BOMの「構造」と「属性」の柔軟性は完璧になりました。
    次は、少し視点を変えて、Item（設計）の外側にある**「調達と製造」**の具体的なデータの持ち方を見ていきます。
    

### **第5章：調達・製造の実践運用**

**～ProcurementとManufacturingの切り出し～**
Item（設計）とは異なるライフサイクルを持つ「調達（SourcingPolicy）」や「製造工程（ProcessPlan）」を、どのようにCoreとFacetの組み合わせで実現しているか。設計図が変わらなくても仕入先が変わるケースなどを扱います。

- 詳細
    
    ## 第5章：調達・製造の実践運用
    
    **～ProcurementとManufacturingの切り出し～**
    
    第4章の「Context（場所の視点）」がここで火を吹きます。
    BizPM氏の設計では、`Item`（モノ）に直接「仕入先」や「製造工程」を書くことを禁止しています。なぜなら、**1つの部品に対して仕入先は複数あるかもしれない**からです。
    
    ### 1. Procurement（調達）： 「3角関係」を作る
    
    「この部品（Item A）は、**誰から**、**いくらで**、**どんな条件で**買うの？」
    この問いに答えるために、以下の3つのテーブルで三角形を作ります。
    
    1. **ItemRev**（設計）： 「欲しいモノの仕様（例：抵抗器 100Ω）」
    2. **Supplier**（相手）： 「売ってくれる人（例：村田製作所）」
    3. **SourcingPolicy**（契約）： **「この場所（Context）では、この人から、この条件で買う」**
    
    ### データの動き（シナリオ）
    
    例えば、あるネジについて、工場ごとに事情が異なるとします。
    
    - **Item:** ネジA（世界共通）
    - **Context: 京都工場**
        - `SourcingPolicy`: 大阪の商社Aから買う。
        - `FacetInstance`: リードタイム=2日、通貨=JPY、MOQ=100個
    - **Context: 北米工場**
        - `SourcingPolicy`: 現地のメーカーBから買う。
        - `FacetInstance`: リードタイム=14日、通貨=USD、MOQ=5000個
    
    **ポイント：**
    もし `Item` テーブルに「仕入先」というカラムを作っていたら、この「工場ごとの使い分け」ができません。`SourcingPolicy` として独立させ、そこに `Context` を噛ませることで、**マルチソース（複数社購買）**を実現しています。
    
    ### 価格（PriceCondition）の分離
    
    さらに価格は `PriceCondition` に切り出されています。
    
    - 「1～99個までは100円」
    - 「100個以上なら80円」
    - 「来月からは値上げ」
    こうした複雑な条件（階段価格・有効期限）を管理するためには、専用のオブジェクトが必要です。ここでも詳細は JSON（Facet）に逃がすことで、複雑な計算式に対応できます。
    
    ### 2. Manufacturing（製造）： 「手順」を管理する
    
    BOM（部品表）は「材料リスト」ですが、料理には「手順書（レシピ）」も必要です。これを製造業では **BOP (Bill of Process)** と呼びます。
    
    BizPM氏の設計では、以下のオブジェクトでこれを実現しています。
    
    - **ProcessPlan（工程計画）：** 「どうやって作るか」の全体図。
    - **Operation（工程）：** 手順の1ステップ。「切断」「組立」「検査」など。
    - **ComponentUsage（部材使用）：** **「どの工程で、BOMの中のどの部品を使うか」**。
    
    ### 構造のイメージ
    
    コード スニペット
    
    `ProcessPlan (モーター組立手順)
      │
      ├── Operation 10: 軸の圧入 (設備: プレス機A)
      │      └── ComponentUsage: 軸 (BOMの部品A) をここで消費
      │
      ├── Operation 20: コイル巻き (設備: 巻線機B)
      │      └── ComponentUsage: 銅線 (BOMの部品B) をここで消費
      │
      └── Operation 30: 検査 (場所: 検査台)
             └── (部品消費なし、検査記録のみ)`
    
    **ここでのFacetの役割：**
    「プレス機の圧力設定」や「検査の合格基準値」といった細かい製造条件は、それぞれの `Operation` に対して `FacetInstance`（製造用ファセット）を貼り付けて管理します。
    
    ### 3. なぜここまで分けるのか？（メリット）
    
    初心者は「BOMの中に『使用工程』というカラムを作ればいいのでは？」と考えがちです。しかし、この設計のようにオブジェクトを分けることで、以下の強力なメリットが生まれます。
    
    1. **設計変更の影響を最小化できる：**
        - 設計者が図面（ItemRev）を少し変えても、購買条件（SourcingPolicy）や製造手順（ProcessPlan）はそのまま使えることが多いです。データが分かれているので、連動して全部書き直す必要がありません。
    2. **「同じモノでも作り方が違う」に対応できる：**
        - 試作ラインでは手作業（ProcessPlan A）、量産ラインではロボット（ProcessPlan B）。同じItemRevに対して複数のPlanを持てます。
    
    ---
    
    ### 第5章のまとめ
    
    1. *調達（Procurement）**は、`ItemRev` と `Supplier` の間の契約関係を `SourcingPolicy` で管理する。
    2. *製造（Manufacturing）**は、BOMとは別に `ProcessPlan`（手順）を持ち、`Operation`（工程）ごとに部品を割り当てる（ComponentUsage）。
    3. 詳細な条件（価格テーブル、設備設定値など）は、それぞれのオブジェクトに紐づく **Facet** に逃がす。
    
    これで、設計から調達、製造までのデータ構造がつながりました。
    しかし、ここまで柔軟にデータ（JSON）を分散させると、一つだけ**致命的な問題**が発生します。
    

### **第6章：検索性能と柔軟性のトレードオフ**

**～JSONスキーマとFacetPropertyIndex～**
JSONでデータを柔軟に持つことの副作用（検索が遅い）をどう解決するか？BizPMが提案している「FacetPropertyIndex（検索用索引）」の役割と、技術的な実装パターン（A/B/C案）の勘所を押さえます。

- 詳細
    
    **第6章：検索性能と柔軟性のトレードオフ**
    **～JSONスキーマとFacetPropertyIndex～**
    第3章で、私たちは属性を FacetInstance の中にある JSON（values_json）に逃がしました。
    これで「管理項目を無限に増やせる」という柔軟性を手に入れましたが、データベースの世界には**「柔軟なデータは、検索が遅い」**という絶対的な法則があります。
    **1. なぜJSONの検索は遅いのか？**
    図書館で例えてみましょう。
    • **普通のテーブル（固定列）での検索：**
        ◦ 「『著者名』が『夏目漱石』の本を探して」
        ◦ 図書館の検索カード（インデックス）は「著者名」で整理されているので、**一瞬で**見つかります。
    • **JSON（Facet）での検索：**
        ◦ 「『表紙の備考メモ』の中に『主人公が猫』と書いてある本を探して」
        ◦ 備考メモは整理されておらず、あらゆる情報がごちゃ混ぜに書かれています。
        ◦ 司書さんは、図書館中の本を**一冊ずつ開いて、メモを全部読んで確認**しなければなりません。
        ◦ これをDB用語で**「フルスキャン」**と言います。データが100万件あったらシステムが停止するほど遅くなります。
    **2. BizPMの解決策： `FacetPropertyIndex`**
    そこでBizPM氏は、**「検索しそうな項目だけ、検索しやすい形にしてコピーしておく」**という解決策を用意しました。これが `FacetPropertyIndex` テーブルです。
    **仕組み：索引（インデックス）の作成**
    ユーザーが画面で「電圧：12V」と入力して保存ボタンを押した瞬間、システム裏側では**2つの書き込み**が行われます。
    1. **正のデータ保存：** `FacetInstance` のJSONに全て書き込む。（これは今まで通り）
    2. **検索用データのコピー：** `FacetPropertyIndex` に、「電圧」というキーと「12」という値を書き込む。
    **データの形（縦持ち / EAV）**
    `FacetPropertyIndex` テーブルの中身は、辞書のような形になっています。**Instance IDKey (項目名)Value_StringValue_Number**FI-001**voltage**NULL**12**FI-001**colorRed**NULLFI-002**voltage**NULL**24**
    こうしておけば、ユーザーが「電圧が10V以上の部品を検索！」と言ったとき、システムは重たいJSONを見に行かず、この**整理された `FacetPropertyIndex` テーブルだけを高速にチェック**すれば良いのです。
    **3. 三つのパターンの落とし所**
    BizPM氏の資料にある「パターンA・B・C」の議論は、まさにこのトレードオフの話です。
    • **パターンA（固定スキーマ）：** 全部カラムにする。
        ◦ 検索：爆速。
        ◦ 柔軟性：最悪（開発が必要）。
    • **パターンB（完全JSON）：** 全部JSONにする。
        ◦ 検索：遅い（工夫しないと死ぬ）。
        ◦ 柔軟性：最高。
    • **パターンC（ハイブリッド ＋ Index）：今回の採用案**
        ◦ **検索したい項目（頻出キー）だけ**を `FacetPropertyIndex` に入れる。
        ◦ 「備考」のような検索しない長い文章は、Indexに入れない（容量の節約）。
    **4. メリットとデメリット（コスト）**
    この方式は「魔法」ではなく、コストも支払っています。
    • **メリット：**
        ◦ ユーザー定義項目であっても、まるで固定カラムかのようなスピードで検索・集計ができる。
        ◦ 「電圧」の平均値を出す、などの分析クエリも高速。
    • **デメリット（コスト）：**
        ◦ **容量が2倍になる：** 同じデータをJSONとIndexテーブルの2箇所に持つため、ストレージ容量を食います。
        ◦ **書き込みがわずかに遅くなる：** 保存ボタンを押した時の処理が2倍になります（人間には感知できないレベルですが）。
    BizPM氏はこのコストを払ってでも、**「ユーザーが自由に項目を増やせて、かつサクサク検索できる体験」**を優先したということです。これはSaaSなどのマルチテナント型BOMシステムでは定石かつ正解のアーキテクチャです。
    **第6章のまとめ**
    1. JSONにデータを逃がすと、柔軟性は上がるが**検索性能が落ちる**。
    2. 解決策として、検索に必要なキーだけを抽出した **`FacetPropertyIndex`（検索用索引テーブル）** を作る。
    3. これにより、**「書き込み時の少しの手間」で「読み取り時の高速なスピード」を買う**という設計判断をしている。
    ここまでで、データの持ち方から検索の仕組みまで、裏側の構造はすべて理解できました。
    最後に、これらが実際の業務でどう流れていくのか、全体像をシミュレーションして終わりにしましょう。
    

### **第7章：全体像とデータフローの総まとめ**

**～ER図の読解と運用シミュレーション～**
これまでの知識を統合し、最後に提示されたER図を読み解きます。「ある部品を登録し、属性をつけ、BOMを組み、調達先を決める」という一連のデータフローを脳内でシミュレーションして完成とします。

- 詳細
    
    ## 第7章：全体像とデータフローの総まとめ
    
    **～ER図の読解と運用シミュレーション～**
    
    これまでの章で、BizPM氏の設計したパーツ（部品）はすべて揃いました。
    最後に、**「新しい電動ドリル（型番：DR-X100）」**を開発・製造するというシナリオで、データがどのように生まれ、流れていくかをシミュレーションします。
    
    頭の中で、システム画面を操作しているつもりで追いかけてください。
    
    ### シミュレーション開始
    
    ### Step 1: モノの誕生（Core）
    
    **～第1章：ItemとItemRev～**
    
    まず、設計者がシステムに「電動ドリル」を登録します。
    
    1. **Item作成:** 品番 `DR-X100`、名称 `Pro Drill X` を登録。
        - → `Item` テーブルに1行できる。
    2. **Revision作成:** まだ開発中なので `Rev A` を作成。
        - → `ItemRev` テーブルに1行できる。
    
    > 状態： まだ「IDカード」が発行されただけです。スペックも構成も空っぽです。
    > 
    
    ### Step 2: 属性の付与（Facet & Index）
    
    **～第3章・第6章：FacetとIndex～**
    
    設計者はこのドリルの仕様を入力します。
    
    1. **Facet選択:** 「製品スペック（一般）」という `FacetType` を選ぶ。
    2. **値の入力:** 電圧=`18V`、重量=`1.5kg` と入力して保存。
        - → `FacetInstance` にJSONとして保存される（柔軟性）。
        - → 同時に `FacetPropertyIndex` に「18V」「1.5kg」がコピーされる（検索性）。
    
    > 状態： これで「18Vのドリルである」ことが検索可能になりました。
    > 
    
    ### Step 3: 構成を作る（BOM Structure）
    
    **～第2章：BOMHeaderとBOMLine～**
    
    「このドリルは何でできているか？」を定義します。
    
    1. **Header作成:** 「設計BOM (EBOM)」という `BOMHeader` を作る。
    2. **Line追加:**
        - モーター（P/N: MT-500, Rev C）を1個。
        - 筐体ケース（P/N: CS-200, Rev B）を1個。
        - → `BOMLine` テーブルに2行追加され、親（ドリル）と子（モーター、ケース）が繋がる。
    
    > 状態： 親子関係（ツリー）ができました。
    > 
    
    ### Step 4: 工場ごとの事情（Context & Effectivity）
    
    **～第4章：Context～**
    
    「実は、寒冷地の北米工場では、バッテリーを寒冷地仕様に変えたい」という要件が出ました。
    
    1. **Context切り替え:** 視点を「北米工場 (Context: US-Plant)」に切り替える。
    2. **Line変更:** 標準バッテリーを削除し、「寒冷地バッテリー」を追加。
        - → 設計BOM（EBOM）は汚さず、北米用の製造BOM（MBOM）として別の `BOMHeader` または `Context` 差分が保存される。
    
    > 状態： 1つの品番 DR-X100 なのに、日本で見ると標準仕様、北米で見ると寒冷地仕様のBOMが表示されるようになりました。
    > 
    
    ### Step 5: 調達と製造（Procurement & Mfg）
    
    **～第5章：調達・製造～**
    
    最後に、北米工場で実際にモノを作ります。
    
    1. **調達（SourcingPolicy）:**
        - モーター（MT-500）は、北米工場では「現地のサプライヤーB社」から買う。
        - → `SourcingPolicy` で定義済み。
    2. **製造（ProcessPlan）:**
        - 北米ライン専用の「組立手順書（ProcessPlan）」を呼び出す。
        - `Operation 10`（組立）で、BOMの「寒冷地バッテリー」を使用部材（ComponentUsage）として消費する。
    
    ---
    
    ### 全体像の結論：なぜこの設計は優れているのか？
    
    このBizPM氏のアーキテクチャは、以下の3つの「矛盾」を見事に解決しています。
    
    1. **「固定」と「自由」の矛盾**
        - **Core**でガチガチに管理（データの整合性）しつつ、**Facet**で好き勝手に属性を増やせる（現場の利便性）。
    2. **「共通」と「個別」の矛盾**
        - 品番（Item）は世界共通にしつつ、**Context**で見え方（BOMや調達先）をローカルに最適化できる。
    3. **「柔軟」と「速度」の矛盾**
        - JSONで柔軟性を持ちつつ、**Index**で検索速度を落とさない。
    
    ### ディスカッションへの準備は完了です
    
    これで、あなたはBizPM氏が作成したファイル、ER図、そしてその背後にある設計思想を完全に理解しました。
    
    河野さん（BizPM）とのディスカッションでは、以下のように伝えると非常にスムーズかと思います。
    
    > 「CoreとFacetの分離、そしてContextによる多次元管理の意図、理解しました。スーパーテーブル問題を回避しつつ、検索性能もIndexで担保する、非常にバランスの良い設計ですね。
    具体的な運用として、**FacetTypeの管理権限（誰が勝手に項目を増やしていいか）**や、Contextが増えすぎた時の統制について、運用ルールを詰めさせてください。」
    >